/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * FilterInputPanel.java
 *
 * Created on 09-May-2011, 13:17:33
 */
package uk.ac.uea.cmp.srnaworkbench.tools.filter;

import uk.ac.uea.cmp.srnaworkbench.tools.ToolParameters;
import uk.ac.uea.cmp.srnaworkbench.tools.ToolParamsHost;
import java.io.File;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.swing.JOptionPane;
import javax.swing.text.DefaultFormatterFactory;
import uk.ac.uea.cmp.srnaworkbench.history.HistoryFileType;

import uk.ac.uea.cmp.srnaworkbench.utils.FileDialogUtils.FileExtFilter;
import uk.ac.uea.cmp.srnaworkbench.utils.RegexPatternFormatter;

import static uk.ac.uea.cmp.srnaworkbench.tools.filter.FilterParams.Definition.*;
import static uk.ac.uea.cmp.srnaworkbench.utils.FileDialogUtils.FileExtFilter.*;
import uk.ac.uea.cmp.srnaworkbench.utils.LOGGERS.WorkbenchLogger;

/**
 * Manages a @link{FilterParams} object from a GUI panel.
 * @author Matthew Stocks and Dan Mapleson
 */
public final class FilterInputPanel extends javax.swing.JPanel implements ToolParamsHost
{
  private FilterParams f_params;
  
  /** Creates new form FilterInputPanel */
  public FilterInputPanel()
  {
    // Init GUI components
    initComponents();

    // Init variables
    this.f_params = null;

    this.setEnabled( false );
    
    // Formatter for number params text boxes
    java.util.regex.Pattern numberFilter = java.util.regex.Pattern.compile( "[0-9]*" );
    RegexPatternFormatter numberRegexFormatter = new RegexPatternFormatter( numberFilter );
    numberRegexFormatter.setAllowsInvalid( false );
    DefaultFormatterFactory numberFactory = new DefaultFormatterFactory( numberRegexFormatter );
    this.txtMinAbundance.setFormatterFactory( numberFactory );
    this.txtMaxAbundance.setFormatterFactory( numberFactory );
    this.txtMinLength.setFormatterFactory( numberFactory );
    this.txtMaxLength.setFormatterFactory( numberFactory );
    this.lblMinLenDetails.setText( "(at least " + MINIMUM_LENGTH.getLowerLimit( Integer.class ).toString() + ")");
    this.lblMaxLenDetails.setText( "(no more than " + MAXIMUM_LENGTH.getUpperLimit( Integer.class ).toString() + ")");
      
    int widths[] =
    {
      inputSelectorPanel.getLabelWidth(),
      outputSelectorPanel.getLabelWidth(),
      fspDiscardedLogFile.getLabelWidth(),
      fspGenome.getLabelWidth(),
      fspKillList.getLabelWidth()
    };

    int maxWidth = Integer.MIN_VALUE;
    for ( int currentWidth : widths )
    {
      if ( currentWidth > maxWidth )
      {
        maxWidth = currentWidth;
      }
    }
    inputSelectorPanel.setLabelWidth( maxWidth );
    outputSelectorPanel.setLabelWidth( maxWidth );
    fspDiscardedLogFile.setLabelWidth( maxWidth );
    fspGenome.setLabelWidth( maxWidth );
    fspKillList.setLabelWidth( maxWidth );

    this.inputSelectorPanel.setFilters( 
      FileExtFilter.toFilterArray( FASTA ));
    outputSelectorPanel.setFilters( 
      FileExtFilter.toFilterArray( FASTA ));
    
    fspGenome.setFilters( 
      FileExtFilter.toFilterArray( FASTA ));
    
    reset();
  }

  /** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents()
    {

        pnlProperties = new javax.swing.JPanel();
        lblMinLength = new javax.swing.JLabel();
        lblMaxLength = new javax.swing.JLabel();
        txtMaxLength = new javax.swing.JFormattedTextField();
        txtMinLength = new javax.swing.JFormattedTextField();
        lblMinLenDetails = new javax.swing.JLabel();
        lblMaxLenDetails = new javax.swing.JLabel();
        lblMinAbd = new javax.swing.JLabel();
        txtMinAbundance = new javax.swing.JFormattedTextField();
        txtMaxAbundance = new javax.swing.JFormattedTextField();
        lblMaxAbd = new javax.swing.JLabel();
        chkLowComplexity = new javax.swing.JCheckBox();
        chkFilterInvalidSeq = new javax.swing.JCheckBox();
        chkFilterByNorm = new javax.swing.JCheckBox();
        pnlOutput = new javax.swing.JPanel();
        chkOutputNonRedundant = new javax.swing.JCheckBox();
        chkOutputNormalised = new javax.swing.JCheckBox();
        chkForceOverwrite = new javax.swing.JCheckBox();
        chkOutputRedundant = new javax.swing.JCheckBox();
        pnltrrna = new javax.swing.JPanel();
        chkDiscardTRRNA = new javax.swing.JCheckBox();
        chkTRRNASense = new javax.swing.JCheckBox();
        chkGenomeFilter = new javax.swing.JCheckBox();
        chkKillList = new javax.swing.JCheckBox();
        chkAddDiscardedLog = new javax.swing.JCheckBox();
        jPanel1 = new javax.swing.JPanel();
        fspDiscardedLogFile = new uk.ac.uea.cmp.srnaworkbench.swing.FileSelectorPanel();
        outputSelectorPanel = new uk.ac.uea.cmp.srnaworkbench.swing.FileSelectorPanel();
        inputSelectorPanel = new uk.ac.uea.cmp.srnaworkbench.swing.FileSelectorPanel();
        fspGenome = new uk.ac.uea.cmp.srnaworkbench.swing.FileSelectorPanel();
        fspKillList = new uk.ac.uea.cmp.srnaworkbench.swing.FileSelectorPanel();

        setBackground(new java.awt.Color(120, 120, 120));
        setBorder(javax.swing.BorderFactory.createTitledBorder(null, "Filter Options", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Lucida Sans Unicode", 0, 14), new java.awt.Color(255, 255, 255))); // NOI18N
        setForeground(new java.awt.Color(255, 255, 255));
        setFont(new java.awt.Font("Lucida Sans Unicode", 0, 11)); // NOI18N
        setRequestFocusEnabled(false);

        pnlProperties.setBackground(new java.awt.Color(120, 120, 120));
        pnlProperties.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "sRNA Properties:", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Lucida Sans Unicode", 0, 12), new java.awt.Color(255, 255, 255))); // NOI18N

        lblMinLength.setBackground(new java.awt.Color(120, 120, 120));
        lblMinLength.setFont(new java.awt.Font("Lucida Sans Unicode", 0, 11)); // NOI18N
        lblMinLength.setForeground(new java.awt.Color(255, 255, 255));
        lblMinLength.setText("Min. Length:");

        lblMaxLength.setBackground(new java.awt.Color(120, 120, 120));
        lblMaxLength.setFont(new java.awt.Font("Lucida Sans Unicode", 0, 11)); // NOI18N
        lblMaxLength.setForeground(new java.awt.Color(255, 255, 255));
        lblMaxLength.setText("Max. Length:");

        txtMaxLength.setText("35");
        txtMaxLength.setToolTipText("<html> The maximum length for sequences in the sRNA dataset. </html>");
        txtMaxLength.setEnabled(false);
        txtMaxLength.setFont(new java.awt.Font("Lucida Sans Unicode", 0, 11)); // NOI18N

        txtMinLength.setText("16");
        txtMinLength.setToolTipText("<html> The minimum length for sequences in the sRNA dataset. </html>");
        txtMinLength.setEnabled(false);
        txtMinLength.setFont(new java.awt.Font("Lucida Sans Unicode", 0, 11)); // NOI18N

        lblMinLenDetails.setBackground(new java.awt.Color(120, 120, 120));
        lblMinLenDetails.setFont(new java.awt.Font("Lucida Sans Unicode", 0, 11)); // NOI18N
        lblMinLenDetails.setForeground(new java.awt.Color(255, 255, 255));
        lblMinLenDetails.setText("(at least 16)");

        lblMaxLenDetails.setBackground(new java.awt.Color(120, 120, 120));
        lblMaxLenDetails.setFont(new java.awt.Font("Lucida Sans Unicode", 0, 11)); // NOI18N
        lblMaxLenDetails.setForeground(new java.awt.Color(255, 255, 255));
        lblMaxLenDetails.setText("(no more than 35)");

        lblMinAbd.setBackground(new java.awt.Color(120, 120, 120));
        lblMinAbd.setFont(new java.awt.Font("Lucida Sans Unicode", 0, 11)); // NOI18N
        lblMinAbd.setForeground(new java.awt.Color(255, 255, 255));
        lblMinAbd.setText("Min. Abundance:");

        txtMinAbundance.setToolTipText("<html> \nThe minimum abundance for distinct sequences in the sRNA dataset. <br/>\nThe abundance of a given distinct sequence represents the number of duplicates found for that sequence. \n </html>");
        txtMinAbundance.setEnabled(false);
        txtMinAbundance.setFont(new java.awt.Font("Lucida Sans Unicode", 0, 11)); // NOI18N

        txtMaxAbundance.setToolTipText("<html> \nThe maximum abundance for distinct sequences in the sRNA dataset. <br/>\nThe abundance of a given distinct sequence represents the number of duplicates found for that sequence. \n</html>");
        txtMaxAbundance.setEnabled(false);
        txtMaxAbundance.setFont(new java.awt.Font("Lucida Sans Unicode", 0, 11)); // NOI18N

        lblMaxAbd.setBackground(new java.awt.Color(120, 120, 120));
        lblMaxAbd.setFont(new java.awt.Font("Lucida Sans Unicode", 0, 11)); // NOI18N
        lblMaxAbd.setForeground(new java.awt.Color(255, 255, 255));
        lblMaxAbd.setText("Max. Abundance:");

        chkLowComplexity.setBackground(new java.awt.Color(120, 120, 120));
        chkLowComplexity.setFont(new java.awt.Font("Lucida Sans Unicode", 0, 11)); // NOI18N
        chkLowComplexity.setForeground(new java.awt.Color(255, 255, 255));
        chkLowComplexity.setText("Filter Low Complexity");
        chkLowComplexity.setToolTipText("If enabled, all sequences containing fewer than 3 distinct nucleotides will be discarded.");
        chkLowComplexity.setEnabled(false);

        chkFilterInvalidSeq.setBackground(new java.awt.Color(120, 120, 120));
        chkFilterInvalidSeq.setFont(new java.awt.Font("Lucida Sans Unicode", 0, 11)); // NOI18N
        chkFilterInvalidSeq.setForeground(new java.awt.Color(255, 255, 255));
        chkFilterInvalidSeq.setText("Filter Invalid Sequences");
        chkFilterInvalidSeq.setToolTipText("If enabled, all sequences containing nucleotides other than {A,T,G,C} will be discarded.");
        chkFilterInvalidSeq.setEnabled(false);

        chkFilterByNorm.setBackground(new java.awt.Color(120, 120, 120));
        chkFilterByNorm.setFont(new java.awt.Font("Lucida Sans Unicode", 0, 11)); // NOI18N
        chkFilterByNorm.setForeground(new java.awt.Color(255, 255, 255));
        chkFilterByNorm.setText("Filter By Normalised Abundance");
        chkFilterByNorm.setToolTipText("If selected RPM normalisation over all sequences is performed (not genome matching)");
        chkFilterByNorm.setEnabled(false);
        chkFilterByNorm.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                chkFilterByNormActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout pnlPropertiesLayout = new javax.swing.GroupLayout(pnlProperties);
        pnlProperties.setLayout(pnlPropertiesLayout);
        pnlPropertiesLayout.setHorizontalGroup(
            pnlPropertiesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnlPropertiesLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(pnlPropertiesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(lblMaxLength, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(lblMinLength, javax.swing.GroupLayout.PREFERRED_SIZE, 78, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(pnlPropertiesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(txtMinLength)
                    .addComponent(txtMaxLength, javax.swing.GroupLayout.PREFERRED_SIZE, 63, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(pnlPropertiesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(lblMinLenDetails)
                    .addComponent(lblMaxLenDetails))
                .addGap(18, 18, 18)
                .addGroup(pnlPropertiesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(lblMaxAbd, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(lblMinAbd, javax.swing.GroupLayout.PREFERRED_SIZE, 95, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(pnlPropertiesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(txtMinAbundance)
                    .addComponent(txtMaxAbundance, javax.swing.GroupLayout.PREFERRED_SIZE, 63, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(pnlPropertiesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(chkLowComplexity, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(pnlPropertiesLayout.createSequentialGroup()
                        .addGroup(pnlPropertiesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(chkFilterByNorm)
                            .addComponent(chkFilterInvalidSeq))
                        .addGap(0, 36, Short.MAX_VALUE)))
                .addContainerGap())
        );
        pnlPropertiesLayout.setVerticalGroup(
            pnlPropertiesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnlPropertiesLayout.createSequentialGroup()
                .addGroup(pnlPropertiesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(pnlPropertiesLayout.createSequentialGroup()
                        .addComponent(lblMinLength, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(lblMaxLength, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(pnlPropertiesLayout.createSequentialGroup()
                        .addGroup(pnlPropertiesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(lblMinAbd, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(txtMinAbundance, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(chkLowComplexity))
                        .addGap(5, 5, 5)
                        .addGroup(pnlPropertiesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(lblMaxAbd, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(txtMaxAbundance, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(chkFilterInvalidSeq)))
                    .addGroup(pnlPropertiesLayout.createSequentialGroup()
                        .addGroup(pnlPropertiesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(txtMinLength, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(lblMinLenDetails, javax.swing.GroupLayout.PREFERRED_SIZE, 21, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(5, 5, 5)
                        .addGroup(pnlPropertiesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(txtMaxLength, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(lblMaxLenDetails, javax.swing.GroupLayout.PREFERRED_SIZE, 22, javax.swing.GroupLayout.PREFERRED_SIZE))))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(chkFilterByNorm)
                .addContainerGap(9, Short.MAX_VALUE))
        );

        pnlOutput.setBackground(new java.awt.Color(120, 120, 120));
        pnlOutput.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "Output:", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Lucida Sans Unicode", 0, 12), new java.awt.Color(255, 255, 255))); // NOI18N

        chkOutputNonRedundant.setBackground(new java.awt.Color(120, 120, 120));
        chkOutputNonRedundant.setFont(new java.awt.Font("Lucida Sans Unicode", 0, 11)); // NOI18N
        chkOutputNonRedundant.setForeground(new java.awt.Color(255, 255, 255));
        chkOutputNonRedundant.setSelected(true);
        chkOutputNonRedundant.setText("Output Non-Redundant Files");
        chkOutputNonRedundant.setToolTipText("<html>\nIf enabled, the FastA output will be in non-redundant form: \">seq(abd)\\nseq\\n\". <br>\nIf disabled, the FastA output will be in redundant form: \">seq\\nseq\\n\", with duplicate sequences repeated.\n</html>");
        chkOutputNonRedundant.setEnabled(false);

        chkOutputNormalised.setBackground(new java.awt.Color(120, 120, 120));
        chkOutputNormalised.setFont(new java.awt.Font("Lucida Sans Unicode", 0, 11)); // NOI18N
        chkOutputNormalised.setForeground(new java.awt.Color(255, 255, 255));
        chkOutputNormalised.setText("Output Normalised Values");
        chkOutputNormalised.setToolTipText("If selected RPM normalisation over all sequences is performed and output (not genome matching)");
        chkOutputNormalised.setEnabled(false);

        chkForceOverwrite.setBackground(new java.awt.Color(120, 120, 120));
        chkForceOverwrite.setFont(new java.awt.Font("Lucida Sans Unicode", 0, 11)); // NOI18N
        chkForceOverwrite.setForeground(new java.awt.Color(255, 255, 255));
        chkForceOverwrite.setText("Force Overwriting of files");
        chkForceOverwrite.setToolTipText("<html> If enabled, any files found within the selected output directory <br> that have the same name as the newly created filtered files will be overwritten.<br>If disabled, any such files will be ignored</html>");
        chkForceOverwrite.setEnabled(false);

        chkOutputRedundant.setBackground(new java.awt.Color(120, 120, 120));
        chkOutputRedundant.setFont(new java.awt.Font("Lucida Sans Unicode", 0, 11)); // NOI18N
        chkOutputRedundant.setForeground(new java.awt.Color(255, 255, 255));
        chkOutputRedundant.setText("Output Redundant Files");
        chkOutputRedundant.setToolTipText("If selected RPM normalisation over all sequences is performed and output (not genome matching)");
        chkOutputRedundant.setEnabled(false);

        javax.swing.GroupLayout pnlOutputLayout = new javax.swing.GroupLayout(pnlOutput);
        pnlOutput.setLayout(pnlOutputLayout);
        pnlOutputLayout.setHorizontalGroup(
            pnlOutputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnlOutputLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(pnlOutputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(chkOutputRedundant)
                    .addComponent(chkOutputNormalised)
                    .addComponent(chkForceOverwrite)
                    .addComponent(chkOutputNonRedundant))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        pnlOutputLayout.setVerticalGroup(
            pnlOutputLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnlOutputLayout.createSequentialGroup()
                .addComponent(chkOutputRedundant)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(chkOutputNonRedundant)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(chkForceOverwrite)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(chkOutputNormalised)
                .addContainerGap())
        );

        pnltrrna.setBackground(new java.awt.Color(120, 120, 120));
        pnltrrna.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "Transfer and Ribosomal RNA filtering:", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Lucida Sans Unicode", 0, 12), new java.awt.Color(255, 255, 255))); // NOI18N

        chkDiscardTRRNA.setBackground(new java.awt.Color(120, 120, 120));
        chkDiscardTRRNA.setFont(new java.awt.Font("Lucida Sans Unicode", 0, 11)); // NOI18N
        chkDiscardTRRNA.setForeground(new java.awt.Color(255, 255, 255));
        chkDiscardTRRNA.setText("Discard t/t RNA");
        chkDiscardTRRNA.setToolTipText("If enabled, all sRNAs that match to known transfer or ribosomal RNAs will be discarded.");
        chkDiscardTRRNA.setEnabled(false);
        chkDiscardTRRNA.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                chkDiscardTRRNAActionPerformed(evt);
            }
        });

        chkTRRNASense.setBackground(new java.awt.Color(120, 120, 120));
        chkTRRNASense.setFont(new java.awt.Font("Lucida Sans Unicode", 0, 11)); // NOI18N
        chkTRRNASense.setForeground(new java.awt.Color(255, 255, 255));
        chkTRRNASense.setText("Sense Strand only");
        chkTRRNASense.setToolTipText("If enabled, and discard t/t RNAs are enabled, then only transfer and ribosomal matches on the sense strand are discarded.");
        chkTRRNASense.setEnabled(false);

        chkGenomeFilter.setBackground(new java.awt.Color(120, 120, 120));
        chkGenomeFilter.setFont(new java.awt.Font("Lucida Sans Unicode", 0, 11)); // NOI18N
        chkGenomeFilter.setForeground(new java.awt.Color(255, 255, 255));
        chkGenomeFilter.setText("Filter reads that do not match the genome");
        chkGenomeFilter.setToolTipText("If enabled, all sequences containing fewer than 3 distinct nucleotides will be discarded.");

        chkKillList.setBackground(new java.awt.Color(120, 120, 120));
        chkKillList.setFont(new java.awt.Font("Lucida Sans Unicode", 0, 11)); // NOI18N
        chkKillList.setForeground(new java.awt.Color(255, 255, 255));
        chkKillList.setText("Filter reads based on kill list");
        chkKillList.setToolTipText("If enabled, all sequences containing fewer than 3 distinct nucleotides will be discarded.");

        chkAddDiscardedLog.setBackground(new java.awt.Color(120, 120, 120));
        chkAddDiscardedLog.setFont(new java.awt.Font("Lucida Sans Unicode", 0, 11)); // NOI18N
        chkAddDiscardedLog.setForeground(new java.awt.Color(255, 255, 255));
        chkAddDiscardedLog.setText("Add files to discarded sequence log");
        chkAddDiscardedLog.setToolTipText("If enabled, all sequences containing fewer than 3 distinct nucleotides will be discarded.");

        javax.swing.GroupLayout pnltrrnaLayout = new javax.swing.GroupLayout(pnltrrna);
        pnltrrna.setLayout(pnltrrnaLayout);
        pnltrrnaLayout.setHorizontalGroup(
            pnltrrnaLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnltrrnaLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(pnltrrnaLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(pnltrrnaLayout.createSequentialGroup()
                        .addComponent(chkTRRNASense)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(chkDiscardTRRNA)
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addComponent(chkGenomeFilter, javax.swing.GroupLayout.DEFAULT_SIZE, 279, Short.MAX_VALUE)
                    .addComponent(chkKillList, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(chkAddDiscardedLog, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        pnltrrnaLayout.setVerticalGroup(
            pnltrrnaLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnltrrnaLayout.createSequentialGroup()
                .addGroup(pnltrrnaLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(chkDiscardTRRNA)
                    .addComponent(chkTRRNASense))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(chkGenomeFilter)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(chkKillList)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(chkAddDiscardedLog)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        jPanel1.setBackground(new java.awt.Color(120, 120, 120));
        jPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "File I/O", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Lucida Sans Unicode", 0, 11), new java.awt.Color(255, 255, 255))); // NOI18N

        fspDiscardedLogFile.setToolTipText("Optional: If a path is specified, all sequences that are filtered out are logged at this location.");
        fspDiscardedLogFile.setFilters(FileExtFilter.toFilterArray(FileExtFilter.FASTA));
        fspDiscardedLogFile.setFont(new java.awt.Font("Lucida Sans Unicode", 0, 11)); // NOI18N
        fspDiscardedLogFile.setLabel("Discarded Sequence Directory (Optional): ");
        fspDiscardedLogFile.setSelector(uk.ac.uea.cmp.srnaworkbench.swing.FileSelector.DIRECTORY);
        fspDiscardedLogFile.setToolName("Filter");

        outputSelectorPanel.setHistorySingleMode(true);
        outputSelectorPanel.setHistoryType(uk.ac.uea.cmp.srnaworkbench.history.HistoryFileType.SRNA);
        outputSelectorPanel.setLabel("Output Directory (mandatory): ");
        outputSelectorPanel.setSelector(uk.ac.uea.cmp.srnaworkbench.swing.FileSelector.DIRECTORY);
        outputSelectorPanel.setToolName("Filter");

        inputSelectorPanel.setHistorySingleMode(false);
        inputSelectorPanel.setHistoryType(uk.ac.uea.cmp.srnaworkbench.history.HistoryFileType.SRNA);
        inputSelectorPanel.setLabel("Input File Path(s) (mandatory): ");
        inputSelectorPanel.setSelector(uk.ac.uea.cmp.srnaworkbench.swing.FileSelector.MULTI_LOAD);
        inputSelectorPanel.setToolName("Filter");

        fspGenome.setToolTipText("If the genome file path is specified, the filter tool will filter out all sRNAs not aligning to the specified genome.");
        fspGenome.setFilters(FileExtFilter.toFilterArray(FileExtFilter.FASTA));
        fspGenome.setFont(new java.awt.Font("Lucida Sans Unicode", 0, 11)); // NOI18N
        fspGenome.setHistorySingleMode(true);
        fspGenome.setHistoryType(uk.ac.uea.cmp.srnaworkbench.history.HistoryFileType.GENOME);
        fspGenome.setLabel("Genome File Path (optional): ");
        fspGenome.setSelector(uk.ac.uea.cmp.srnaworkbench.swing.FileSelector.LOAD);
        fspGenome.setToolName("Filter");

        fspKillList.setToolTipText("If the Kill List File PAth is specified, the filter tool will discard all sRNAs possessing the same sequence as those in the specified Kill List file.");
        fspKillList.setFilters(FileExtFilter.toFilterArray(FileExtFilter.FASTA));
        fspKillList.setFont(new java.awt.Font("Lucida Sans Unicode", 0, 11)); // NOI18N
        fspKillList.setHistorySingleMode(true);
        fspKillList.setHistoryType(uk.ac.uea.cmp.srnaworkbench.history.HistoryFileType.SRNA);
        fspKillList.setLabel("Kill List File Path (optional): ");
        fspKillList.setSelector(uk.ac.uea.cmp.srnaworkbench.swing.FileSelector.LOAD);
        fspKillList.setToolName("Filter");

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(fspDiscardedLogFile, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(outputSelectorPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(inputSelectorPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(fspGenome, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(fspKillList, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addComponent(inputSelectorPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 102, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(outputSelectorPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(fspDiscardedLogFile, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(fspGenome, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(fspKillList, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(pnlProperties, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(pnltrrna, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(pnlOutput, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(pnlProperties, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(pnlOutput, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(pnltrrna, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        getAccessibleContext().setAccessibleParent(this);
    }// </editor-fold>//GEN-END:initComponents

    private void chkDiscardTRRNAActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_chkDiscardTRRNAActionPerformed
    {//GEN-HEADEREND:event_chkDiscardTRRNAActionPerformed
      this.chkTRRNASense.setEnabled( this.chkDiscardTRRNA.isSelected() ? true : false );
    }//GEN-LAST:event_chkDiscardTRRNAActionPerformed

  private void chkFilterByNormActionPerformed( java.awt.event.ActionEvent evt )//GEN-FIRST:event_chkFilterByNormActionPerformed
  {//GEN-HEADEREND:event_chkFilterByNormActionPerformed

      this.chkOutputNormalised.setEnabled( chkFilterByNorm.isSelected() );
    
  }//GEN-LAST:event_chkFilterByNormActionPerformed

  public void setTextInput( String sRNAPath, String outputPath )
  {
    inputSelectorPanel.setPath( sRNAPath );
    outputSelectorPanel.setPath( outputPath );
  }

  
  @Override
  public final void setEnabled( boolean enabled )
  {
    super.setEnabled( enabled );
    chkLowComplexity.setEnabled( enabled );
    chkDiscardTRRNA.setEnabled( enabled );
    chkFilterInvalidSeq.setEnabled( enabled );
    chkTRRNASense.setEnabled( enabled );
    chkOutputNonRedundant.setEnabled( enabled );
    this.chkOutputRedundant.setEnabled( enabled );
    this.chkForceOverwrite.setEnabled( enabled );
    
    //this.chkOutputNormalised.setEnabled( enabled );

    inputSelectorPanel.setEnabled( enabled );
    outputSelectorPanel.setEnabled( enabled );

    lblMaxAbd.setEnabled( enabled );
    txtMaxAbundance.setEnabled( enabled );
    lblMaxLength.setEnabled( enabled );
    txtMaxLength.setEnabled( enabled );
    lblMaxLenDetails.setEnabled( enabled );
    lblMinAbd.setEnabled( enabled );
    txtMinAbundance.setEnabled( enabled );
    lblMinLength.setEnabled( enabled );
    txtMinLength.setEnabled( enabled );
    lblMinLenDetails.setEnabled( enabled );
    
    this.chkFilterByNorm.setEnabled( enabled );

    fspGenome.setEnabled( enabled );
    fspKillList.setEnabled( enabled );
    fspDiscardedLogFile.setEnabled( enabled );
  }
  
  public final void setIOPanelEnabled( boolean enabled )
  {
    inputSelectorPanel.setEnabled( enabled );
    outputSelectorPanel.setEnabled( enabled );
    fspDiscardedLogFile.setEnabled(enabled);
    
  }
  
  public final void setMakeRedundantEnabled( boolean enabled )
  {
    this.chkOutputNonRedundant.setEnabled( enabled );
    this.chkOutputRedundant.setEnabled( enabled );
    this.chkOutputNormalised.setEnabled( enabled );
  }
  
  public void setMakeRedundant( boolean selected )
  {
    this.chkOutputNonRedundant.setSelected( selected );
  }
  
  /**
   * Resets the filter input panel to default values.
   */
  public void reset()
  {
    f_params = new FilterParams();
    
    setTextInput("","");
    
    this.update( f_params );
  }

  // ***** ToolParamsHost implementation *****

  @Override
  public FilterParams getParams()
  {
    if ( !createParams() )
    {
      return null;
    }

    return this.f_params;
  }
  
  @Override
  public void update( ToolParameters params )
  {
    if ( !( params instanceof FilterParams ) )
    {
      showErrorDialog("Unexpected error: parameters object provided is not a valid filter params file.");
      return;
    }

    FilterParams fp = (FilterParams)params;

    this.txtMinLength.setText( Integer.toString( fp.getMinLength() ) );
    this.txtMaxLength.setText( Integer.toString( fp.getMaxLength() ) );
    this.txtMinAbundance.setText( Integer.toString( fp.getMinAbundance() ) );
    this.txtMaxAbundance.setText( Integer.toString( fp.getMaxAbundance() ) );
    this.chkLowComplexity.setSelected( fp.getFilterLowComplexitySeq() );
    this.chkFilterInvalidSeq.setSelected( fp.getFilterInvalidSeq() );
    this.chkDiscardTRRNA.setSelected( fp.getDiscardTRRNA() );
    this.chkTRRNASense.setSelected( fp.getDiscardTRRNASenseOnly() );
    this.chkOutputNonRedundant.setSelected( fp.getOutputNonRedundant() );
    this.fspGenome.setFilePath( fp.getGenome() );
    this.fspKillList.setFilePath( fp.getKillList() );
    this.fspDiscardedLogFile.setFilePath( fp.getDiscardLog() );
  }

  @Override
  public void showErrorDialog( String message )
  {
    JOptionPane.showMessageDialog( this,
      message,
      "Parameter Error",
      JOptionPane.ERROR_MESSAGE );
  }
  
  // ***** Should move this functionality out of here at some point... it's not required *****
  
  /**
   * If the user has selected genome filtering, then this method returns a boolean
   * indicating that.
   * For external use my miRCat pre-processing dialog only.
   * @return true if genome filtering is requested, false if not.
   */
  public boolean getUsingGenome()
  {
    return this.fspGenome.getFile() != null ? true : false;
  }

  /**
   * Creates an internal object representing the parameters selected by the user.
   * For external use my miRCat pre-processing dialog only.
   * @return true if parameters were built successfully, false if not.
   */
  public boolean getConfig()
  {
    if ( this.isEnabled() )
    {
      return createParams();
    }
    return true;
  }
  
  // ***** End comment *****

  private boolean createParams()
  {
    try
    {
      String min_len_str = this.txtMinLength.getText().trim();
      String max_len_str = this.txtMaxLength.getText().trim();
      String min_abd_str = this.txtMinAbundance.getText().trim();
      String max_abd_str = this.txtMaxAbundance.getText().trim();

      int min_len = min_len_str.length() > 0 ? Integer.parseInt( min_len_str ) : MINIMUM_LENGTH.getDefault( Integer.class );
      int max_len = max_len_str.length() > 0 ? Integer.parseInt( max_len_str ) : MAXIMUM_LENGTH.getDefault( Integer.class );
      int min_abd = min_abd_str.length() > 0 ? Integer.parseInt( min_abd_str ) : MINIMUM_ABUNDANCE.getDefault( Integer.class );
      int max_abd = max_abd_str.length() > 0 ? Integer.parseInt( max_abd_str ) : MAXIMUM_ABUNDANCE.getDefault( Integer.class );

      File genome_file = this.fspGenome.getFile();
      File kill_file = this.fspKillList.getFile();
      File discard_log = this.fspDiscardedLogFile.getFile();

      f_params = new FilterParams.Builder()
        .setMinLength( min_len ).setMaxLength( max_len )
        .setMinAbundance( min_abd ).setMaxAbundance( max_abd )
        .setNormaliseAbundance( this.chkOutputNormalised.isSelected() )
        .setFilterByNormalisedAbundance( this.chkFilterByNorm.isSelected())
        .setFilterLowComplexitySeq( this.chkLowComplexity.isSelected() )
        .setFilterInvalidSeq( this.chkFilterInvalidSeq.isSelected() )
        .setDiscardTRRNA( this.chkDiscardTRRNA.isSelected() )
        .setDiscardTRRNASenseOnly( this.chkTRRNASense.isSelected() )
        .setOutputNonRedundant (this.chkOutputNonRedundant.isSelected() )
        .setOutputRedundant (this.chkOutputRedundant.isSelected() )
        .setFilterGenomeHits( this.chkGenomeFilter.isSelected())
        .setFilterKillList( this.chkKillList.isSelected())
        .setAddDiscardLog( this.chkAddDiscardedLog.isSelected())
        .setGenome( genome_file )
        .setKillList( kill_file )
        .setDiscardLog( discard_log )
        .build();
    }
    catch ( NumberFormatException ex )
    {
      WorkbenchLogger.LOGGER.log( Level.SEVERE, null, ex );
      JOptionPane.showMessageDialog( this,
        ex.getMessage(),
        "Filter Input Error",
        JOptionPane.ERROR_MESSAGE );

      return false;
    }
    return true;
  }

  /**
   * Gets a File object representation of the path described in the input file text box
   * @return File object representation of the path described in the input file text box
   */
  public File getInputFile()
  {
    return this.inputSelectorPanel.getFile();
  }
  
  public ArrayList<File> getInputFiles()
  {
    return this.inputSelectorPanel.getFiles();
  }
  public void addToHistory( ArrayList<String> theInput )
  {
    this.inputSelectorPanel.addToHistory( theInput );
  }

  /**
   * Gets a File object representation of the path described in the output file text box
   * @return File object representation of the path described in the output file text box
   */
  public File getOutputFile()
  {
    return this.outputSelectorPanel.getFile();
  }
 

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JCheckBox chkAddDiscardedLog;
    private javax.swing.JCheckBox chkDiscardTRRNA;
    private javax.swing.JCheckBox chkFilterByNorm;
    private javax.swing.JCheckBox chkFilterInvalidSeq;
    private javax.swing.JCheckBox chkForceOverwrite;
    private javax.swing.JCheckBox chkGenomeFilter;
    private javax.swing.JCheckBox chkKillList;
    private javax.swing.JCheckBox chkLowComplexity;
    private javax.swing.JCheckBox chkOutputNonRedundant;
    private javax.swing.JCheckBox chkOutputNormalised;
    private javax.swing.JCheckBox chkOutputRedundant;
    private javax.swing.JCheckBox chkTRRNASense;
    private uk.ac.uea.cmp.srnaworkbench.swing.FileSelectorPanel fspDiscardedLogFile;
    private uk.ac.uea.cmp.srnaworkbench.swing.FileSelectorPanel fspGenome;
    private uk.ac.uea.cmp.srnaworkbench.swing.FileSelectorPanel fspKillList;
    private uk.ac.uea.cmp.srnaworkbench.swing.FileSelectorPanel inputSelectorPanel;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JLabel lblMaxAbd;
    private javax.swing.JLabel lblMaxLenDetails;
    private javax.swing.JLabel lblMaxLength;
    private javax.swing.JLabel lblMinAbd;
    private javax.swing.JLabel lblMinLenDetails;
    private javax.swing.JLabel lblMinLength;
    private uk.ac.uea.cmp.srnaworkbench.swing.FileSelectorPanel outputSelectorPanel;
    private javax.swing.JPanel pnlOutput;
    private javax.swing.JPanel pnlProperties;
    private javax.swing.JPanel pnltrrna;
    private javax.swing.JFormattedTextField txtMaxAbundance;
    private javax.swing.JFormattedTextField txtMaxLength;
    private javax.swing.JFormattedTextField txtMinAbundance;
    private javax.swing.JFormattedTextField txtMinLength;
    // End of variables declaration//GEN-END:variables

  public boolean getOverwriteConfirm()
  {
    return this.chkForceOverwrite.isSelected();
  }

  
}
